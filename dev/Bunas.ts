 export abstract class GameObject { public area: World.Area; public colBox: {x: number, y: number, width: number, height: number}; public clipBox: {x: number, y: number, width: number, height: number}; public sprite: Graphics.Sprite | HTMLImageElement; public mask: {x: number, y: number}[]; public inView: boolean = true; constructor( public x: number, public y: number, private _z: number = 0, colWidth: number | {x?: number, y?: number, width: number, height?: number} = 0, clipWidth: number | {x?: number, y?: number, width: number, height?: number} = -1 ) { if (typeof colWidth === 'number') { this.colBox = { x: 0, y: 0, width: colWidth, height: colWidth } } else { this.colBox = { x: colWidth.x || 0, y: colWidth.y || 0, width: colWidth.width, height: colWidth.height || colWidth.width } } if (typeof clipWidth === 'number') { if (clipWidth === -1) { this.clipBox = this.colBox; } else { this.clipBox = { x: 0, y: 0, width: clipWidth, height: clipWidth } } } else { this.clipBox = { x: clipWidth.x || 0, y: clipWidth.y || 0, width: clipWidth.width, height: clipWidth.height || clipWidth.width } } World.area.add(this); } get z(): number { return this._z; } set z(newZ: number) { this._z = newZ; this.area.zSort(this); } public step (delta: number): void {}; public startStep?(delta: number): void; public endStep? (delta: number): void; public draw (ctx: CanvasRenderingContext2D, delta: number): void {}; public startDraw?(ctx: CanvasRenderingContext2D, delta: number): void; public endDraw? (ctx: CanvasRenderingContext2D, delta: number): void; public onMouseOver?(m: Input.Mouse): void; public getCollisions(objects: GameObject[], onlyInView: boolean = false): GameObject[] { return objects.filter(o => ( (!onlyInView || o.inView) && o.x + o.colBox.x < this.x + this.colBox.x + this.colBox.width && o.x + o.colBox.x + o.colBox.width > this.x + this.colBox.x && o.y + o.colBox.y < this.y + this.colBox.y + this.colBox.height && o.y + o.colBox.y + o.colBox.height > this.y + this.colBox.y )); } /* Returns true if rectangle defined by parameters is within objects colBox */ public checkCollision(x: number, y: number, w: number = 0, h: number = 0): boolean { return ( x < this.x + this.colBox.x + this.colBox.width && x + w > this.x + this.colBox.x && y < this.y + this.colBox.y + this.colBox.height && y + h > this.y + this.colBox.y ); } public setShadowMask(poly: {x: number, y: number}[] | Graphics.Sprite) { if (typeof poly[0].x === 'number') { this.mask = <{x: number, y: number}[]>poly; } } /* Removes instance from game */ public delete(): void { this.area.remove(this); } } export module Debug { let show : boolean = false, dTCounter : number = +new Date(), logs : string[] = [], permLog : string[] = [], container : HTMLDivElement = document.createElement('div'), output : HTMLPreElement = document.createElement('pre'); container.setAttribute('style', `position: fixed;height: 100vh;padding-top: 20px; top: 0px;left: 20px;width: 60vw;pointer-events: none;text-shadow: 0 0 2px #000;`); container.appendChild(output); export let fontSize : number = 14, color : string = 'dodgerblue', defaultOptions : {[option: string] : boolean} = { dt: true, view: true, input : true }; export function toggle(state?): void { if (state !== show) { show = state === undefined ? !show : state; show ? document.body.appendChild(container) : document.body.removeChild(container); } }; export function log(data: any, persist = false): void { let entry = JSON.stringify(data, null, '\t'); persist ? permLog.push(entry) : logs.push(entry); }; export function clear(): void { permLog = []; }; export function draw(ctx: CanvasRenderingContext2D, dT: number): void { if (+new Date() - dTCounter < 250) { logs = []; return; } dTCounter = +new Date(); output.setAttribute('style', `font-size: ${fontSize};color: ${color};max-height: 100%;overflow: hidden;white-space: pre-wrap;`); output.innerHTML = ''; if (defaultOptions.dt) { output.innerHTML += `dT    : ${dT.toFixed(3)}<br/>`; } if (defaultOptions.view) { output.innerHTML += `View  :<br/>` + `    x: ${World.area.view.x.toFixed(2)},<br/>` + `    y: ${World.area.view.y.toFixed(2)},<br/>` + `    z: ${World.area.view.z.toFixed(2)}<br/>`; } if (defaultOptions.input) { output.innerHTML += `Input : ${getInputData()}<br/><br/>`; } output.innerHTML += permLog.concat(logs).join('<br/>'); output.scrollTop = output.scrollHeight; logs = []; }; function getInputData(): string { var str = []; str.push(`<br/>    keyPressed = [${Input.key.pressed.join(', ')}]`); str.push(`    mouseState =`); str.push(`        x: ${Input.mouse.x}`); str.push(`        y: ${Input.mouse.y}`); if (Input.mouse.left.pressed) str.push(`    left.pressed`); if (Input.mouse.left.dragging) str.push(`    left.dragging ${Input.mouse.left.drag ? ' left.drag' : ''}`); if (Input.mouse.left.dragPts.length) { str.push(`        left.dragPts: [<br/>${Input.mouse.left.dragPts.reduce((str, p) =>str = (str.length > 200 ? '...' + str.substr(-200) : str) + '(' + p.x + ', ' + p.y + ')', '')}]`); } if (Input.mouse.right.pressed) str.push(`    right.pressed`); if (Input.mouse.right.dragging) str.push(`    right.dragging ${Input.mouse.right.drag ? 'right.drag' : ''}`); if (Input.mouse.right.dragPts.length) { str.push(`        right.dragPts: [<br/>${Input.mouse.right.dragPts.reduce((str, p) =>str = (str.length > 200 ? '...' + str.substr(-200) : str) + '(' + p.x + ', ' + p.y + ')', '')}]`); } return str.join('<br/>'); }; } export module Engine { export type AssetRouteList = { sprites? : { [name: string]: string }; sounds? : { [name: string]: string }; bgs? : { [name: string]: string }; }; export type AssetList = { sprites? : { [name: string]: HTMLImageElement }; sounds? : { [name: string]: HTMLAudioElement }; bgs? : { [name: string]: HTMLImageElement }; }; let can: HTMLCanvasElement, ctx: CanvasRenderingContext2D, dT: number = 0, currentT: number = +new Date(), frameDur: number = 33, assets: AssetList; export let preStep: (number)=>void = ()=>{}, postStep: (number)=>void = ()=>{}, preDraw: (CanvasRenderingContext2D, number)=>void = () => {}, postDraw: (CanvasRenderingContext2D, number)=>void = () => {}, cW: number, cH: number; export function getDelta(): number { return dT; }; export function getCanvasEl(): HTMLCanvasElement { return can; }; export function getCanvasContext(): CanvasRenderingContext2D { return ctx; }; export function getSprite(name: string, isCheck: boolean = false): HTMLImageElement { let asset = assets.sprites[name]; if (!asset) { if (isCheck) { return null; } else { console.error(`Bunas Engine Error: No sprite asset with name "${name}" found.`); } } return asset; }; export function getBackground(name: string, isCheck: boolean = false): HTMLImageElement { let asset = assets.bgs[name]; if (!asset) { if (isCheck) { return null; } else { console.error(`Bunas Engine Error: No background asset with name "${name}" found.`); } } return asset; }; export function getSound(name: string, isCheck: boolean = false): HTMLAudioElement { let asset = assets.sounds[name]; if (!asset) { if (isCheck) { return null; } else { console.error(`Bunas Engine Error: No sound asset with name "${name}" found.`); } } return asset; }; let _externalCallback: Function, delayLoad: ()=>void, delayInit: ()=>void, initComplete: boolean = false; document.onreadystatechange = function() { if (document.readyState === 'complete' && delayInit) { delayInit(); } }; export function init( externalCallback: Function, canEl? : string | HTMLElement, canWidth? : number, canHeight? : number ): void { if (initComplete) { console.error('Bunas Error: Engine instance has already been initalised'); return; } if (document.readyState !== 'complete') { delayInit = init.bind(null, externalCallback, canEl, canWidth, canHeight); return; } else { delayInit = null; initComplete = true; } if (canEl) { can = <HTMLCanvasElement>(typeof canEl === 'string' ? document.getElementById(canEl) : canEl); if (canWidth) { can.width = canWidth; } if (canHeight) { can.height = canHeight; } } else { can = document.getElementsByTagName('canvas')[0]; if (!can) { can = document.createElement('canvas'); document.body.appendChild(can); } can.width = canWidth || window.innerWidth; can.height = canHeight || window.innerHeight; } cW = can.width; cH = can.height; ctx = can.getContext('2d'); ctx.imageSmoothingEnabled = false; Input.init(); World.area = new World.Area('globalArea'); World.area.open(); _externalCallback = externalCallback; if (delayLoad) { delayLoad(); } else { initLoop(); } }; let loading : number = 0, assetTotal : number, spriteLoader : any, soundLoader : any, bgLoader : any; export function preLoad( assets : AssetRouteList, loadingDrawFunc? : (ctx: CanvasRenderingContext2D, fractionLoaded: number)=>void ) { if (initComplete) { console.error('Bunas Error: Engine already initalised. Assets can only be preloaded when called before Engine.init()'); return; } if (!loadingDrawFunc) { loadingDrawFunc = function(ctx, fractionLoaded) { ctx.strokeStyle = '#fff'; ctx.fillStyle = '#fff'; ctx.lineWidth = 10; ctx.beginPath(); ctx.arc( 625, 295, 140, (-Math.PI / 2), (-Math.PI / 2) + ((Math.PI * 2) * (1 - fractionLoaded)), false ); ctx.stroke(); } } delayLoad = internalLoad.bind(null, assets, loadingDrawFunc); } function internalLoad( assetRoutes : AssetRouteList, loadingDrawFunc? : (ctx: CanvasRenderingContext2D, fractionLoaded: number)=>void ): void { spriteLoader = assetRoutes.sprites || {}; soundLoader = assetRoutes.sounds || {}; bgLoader = assetRoutes.bgs || {}; assetTotal = Object.keys(spriteLoader).length + Object.keys(soundLoader).length + Object.keys(bgLoader).length; assetLoader(); advanceLoading(loadingDrawFunc); }; function advanceLoading(loadScreen: (ctx: CanvasRenderingContext2D, completion: number)=>void): void { if (loading > 0) { ctx.clearRect(0, 0, cW, cH); loadScreen(ctx, loading / assetTotal); window.requestAnimationFrame(advanceLoading.bind(null, loadScreen)); } else { assets = { sprites : spriteLoader, sounds : soundLoader, bgs : bgLoader }; initLoop(); } }; function assetLoader(): void { for (let element in spriteLoader) { loading += 1; let spr = new Image(); spr.src = spriteLoader[element]; spriteLoader[element] = spr; spr.onload = () => loading -= 1; } for (let element in bgLoader) { loading += 1; let bg = new Image(); bg.src = bgLoader[element]; bgLoader[element] = bg; bg.onload = () => loading -= 1; } for (let element in soundLoader) { loading += 1; let sound = new Audio(); sound.src = soundLoader[element]; soundLoader[element] = sound; sound.volume = 0.1; sound.load(); sound.oncanplaythrough = () => loading -= 1; } }; function initLoop(): void { _externalCallback(); loop(); }; function loop(): void { setTimeout(() => { let newT: number = +new Date(); dT = (newT - currentT) / frameDur; currentT = newT; preStep(dT); World.step(dT); postStep(dT); Input.step(); ctx.clearRect(-1, -1, cW + 1, cH + 1); preDraw(ctx, dT); World.draw(ctx, dT); Debug.draw(ctx, dT); Input.drawCursor(ctx, dT); postDraw(ctx, dT); window.requestAnimationFrame(loop.bind(this)); }, frameDur - (+new Date()) + currentT); }; } export module Graphics { export type keyframeSet = { [property: string] : number[] | number[][] | (number | string)[][] }; export type drawFunction = (frame: { [property: string] : number }, ctx: CanvasRenderingContext2D)=>void; export type spriteState = { duration : number, elements : { [element: string] : keyframeSet }, fr? : number, iteration? : number, easeIn? : string, easeOut? : string, onEnd? : ()=>void }; export interface Sprite { setDuration: (frames: number, perFrame?: boolean)=>void; draw: (ctx: CanvasRenderingContext2D, x: number, y: number, ang?: number)=>void; toggle: (play: boolean, setFrame: number)=>void; reverse: ()=>void; onEnd: ()=>void; }; export function setImageSmoothing(on: boolean) { Engine.getCanvasContext().imageSmoothingEnabled = on; } export class TileSet { private tileSet: HTMLImageElement; public width: number; public height: number; constructor( tileImage: string | HTMLImageElement, tileWidth: number, tileHeight?: number ) { this.tileSet = typeof tileImage === 'string' ? Engine.getBackground(tileImage) : tileImage; this.width = tileWidth; this.height = tileHeight || this.tileSet.height; }; public draw( ctx: CanvasRenderingContext2D, canX: number, canY: number, tileNum: number ): void { ctx.save(); ctx.translate(canX, canY); let x = tileNum * this.width, y = 0; if (x >= this.tileSet.width) { y = Math.floor(x / this.tileSet.width) * this.height; x %= this.tileSet.width; } ctx.drawImage( this.tileSet, x, y, this.width, this.height, 0, 0, this.width, this.height ); ctx.restore(); }; }; export class SpriteSheet implements Sprite { private sprite : HTMLImageElement; private frCurrent : number = 0; private frDur : number; private paused : boolean = false; private reversed : boolean = false; public width : number; public height : number; public onEnd : ()=>void = ()=>{}; constructor( sprite : string | HTMLImageElement, private frTotal: number = 1, duration: number = 0 ) { this.sprite = typeof sprite === 'string' ? Engine.getSprite(sprite) : sprite; this.width = this.sprite.width / frTotal; this.height = this.sprite.height; this.frDur = duration / frTotal; }; get frame(): number { return Math.floor(this.frCurrent); } set frame(val: number) { this.frCurrent = val; } public draw( ctx: CanvasRenderingContext2D, canX: number, canY: number, ang: number = 0, scale: number | number[] = [1, 1] ): void { if (typeof scale === 'number') { scale = [scale, scale]; } ctx.save(); ctx.translate(canX + (this.width / 2), canY + (this.height / 2)); ctx.scale(scale[0], scale[1]); ctx.rotate(ang); let currentFrame = Math.floor(this.frCurrent) * this.width; if (this.reversed) { currentFrame = this.frTotal - currentFrame; } ctx.drawImage( this.sprite, currentFrame, 0, this.width, this.height, -this.width / 2, -this.height / 2, this.width,this.height ); if (this.frDur > 0 && !this.paused) { this.frCurrent += this.frDur; if (this.frCurrent >= this.frTotal) { this.frCurrent = 0; } } ctx.restore(); }; public setDuration(frames: number, perFrame: boolean = false) { this.frDur = perFrame ? frames : frames / this.frTotal; } public toggle(play?: boolean) { if (typeof play === 'undefined') { this.paused = !this.paused; } else { this.paused = !play; } }; public reverse(runBackwards?:boolean) { if (typeof runBackwards === 'undefined') { this.reversed = !this.reversed; } else { this.reversed = runBackwards; } }; }; export class VectorSprite implements Sprite { private fr : number = 0; private paused : boolean = false; public onEnd : () => void = () => {}; constructor( public drawFunction: drawFunction, public keyframeSet: keyframeSet = null, public duration: number = 30 ) { }; public draw(ctx: CanvasRenderingContext2D, x: number, y: number, ang: number = 0) { ctx.save(); ctx.translate(x, y); ctx.rotate(ang); this.drawFunction(this.keyframeSet ? tween(this.keyframeSet, this.fr) : null, ctx); ctx.restore(); if (this.paused) { return; } this.fr += (1 / this.duration) * Engine.getDelta(); if (this.fr > 1 || this.fr < 0) { this.fr = (this.fr + 1) % 1; this.onEnd(); } }; public setDuration(frames: number) { this.duration = this.duration < 0 ? frames * -1 : frames; } public toggle(play?: boolean ) { if (typeof play === 'undefined') { this.paused = !this.paused; } else { this.paused = !play; } }; public reverse(runBackwards?:boolean) { if ( (typeof runBackwards === 'undefined') || (this.duration < 0 && !runBackwards) || (this.duration > 0 && runBackwards) ) { this.duration *= -1; } }; }; export class Emitter extends GameObject { private parts : Particle[] = []; private currentRate : number = 0; private _grav : Physics.Vec; private _size : number[] = [2, 2]; private _color : string = 'dodgerblue'; private _lifespan : number[] = [100, 100]; private _ang : number[] = [0, 0]; private _power : number[] = [1, 1]; private _rate : number[] = [10, 10]; constructor( public x : number, public y : number, ang? : number | number[], power? : number | number[], rate? : number | number[], ) { super(x, y); if (ang) { this._ang = this.configRange(ang); } if (power) { this._power = this.configRange(power); } if (rate) { this._rate = this.configRange(rate); } }; set gravity(g : Physics.Vec | number) { if (typeof g === 'number') { this._grav = new Physics.Vec(g, Math.PI / 2, true); } else { this._grav = g as Physics.Vec; } } set angle(a: number | number[]) { this._ang = this.configRange(a); } set power(a: number | number[]) { this._power = this.configRange(a); } set rate(a: number | number[]) { this._rate = this.configRange(a); } private configRange(p): number[] { if (typeof p === 'object') { return [p[0], p[1] - p[0]]; } else { return [p, 0]; } } public setParticle( size: number | number[], color?: string, lifespan?: number | number[] ) { this._size = this.configRange(size); if (color) { this._color = color; } if (lifespan) { this._lifespan = this.configRange(lifespan); } } public step(dt) { this.currentRate += dt; if (this.currentRate > this._rate[0]) { for(let i = this._rate[0]; i < this.currentRate; i += this._rate[0]) { let s = this._size[0] + (Math.random() * this._size[1]), c = this._color, l = this._lifespan[0] + (Math.random() * this._lifespan[1]), a = this._ang[0] + (Math.random() * this._ang[1]), p = this._power[0] + (Math.random() * this._power[1]); this.parts.push(new Particle(this.x, this.y, s, c, l, new Physics.Vec(p, a, true), (this.currentRate - i) / this._rate[0])); } this.currentRate %= this._rate[0]; this.currentRate += Math.random() * this._rate[1]; } this.parts.forEach((p, i) => { p.lifespan -= dt; if (p.lifespan < 0) { p.delete(this.parts, i); } p.step(this._grav); }); } public draw(ctx, dt) { ctx.beginPath(); this.parts.forEach(p => { p.draw(ctx); }); ctx.fill(); } } class Particle { private opacity: number = 1; public draw: (ctx: CanvasRenderingContext2D)=>void; constructor ( private x : number, private y : number, private size : number = 2, private color : string = 'black', public lifespan : number = 1000, private velocity : Physics.Vec, offset : number = 1 ) { if (!velocity) { this.velocity = new Physics.Vec(0, 0); } this.x += this.velocity.scale(offset).x - (this.size / 2); this.y += this.velocity.scale(offset).y - (this.size / 2); if (this.size <= 2) { this.draw = (ctx) => { ctx.moveTo(this.x, this.y); ctx.rect(this.x, this.y, this.size, this.size); if (this.opacity < 1) { ctx.globalAlpha = this.opacity; } if (ctx.strokeStyle !== this.color) { ctx.strokeStyle = this.color; ctx.stroke(); ctx.beginPath(); } ctx.globalAlpha = 1; } } else { this.draw = (ctx) => { ctx.moveTo(this.x, this.y); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); if (this.opacity < 1) { ctx.globalAlpha = this.opacity; } if (ctx.fillStyle !== this.color) { ctx.fillStyle = this.color; ctx.fill(); ctx.beginPath(); } ctx.globalAlpha = 1; } } }; public step(gravity?: Physics.Vec) { if (gravity) { this.velocity = this.velocity.add(gravity); } this.x += this.velocity.x; this.y += this.velocity.y; } public delete(parts, i) { this.opacity -= 0.2; if (this.opacity <= 0) parts.splice(i, 1); } } function tween(keyframeSet : keyframeSet, currentFrame : number): {[param : string] : number} { let params = {}; for (let key in keyframeSet) { if (typeof keyframeSet[key] === 'number') { params[key] = keyframeSet[key]; } else { params[key] = interpolate(keyframeSet[key], currentFrame); } } return params; }; function interpolate(keyframe: number[] | number[][] | (number|string)[][], currentFrame: number): number { let nextKeyframe = 0; keyframe = keyframe as number[] | number[][] | (number|string)[][]; if (typeof keyframe[0] === 'number') { keyframe = (keyframe as number[]).map((k, i) => [i / (keyframe as number[]).length, k]); } for(let k = 0; k < keyframe.length; k++) { if (currentFrame < keyframe[k][0]) { nextKeyframe = k; break; } } let end = keyframe[nextKeyframe], start = keyframe[nextKeyframe === 0 ? keyframe.length - 1 : nextKeyframe - 1]; if (end[0] === 1) { end[0] = 0.9999; } let frameDiff = (1 + end[0] - start[0]) % 1; return Easings[start[2] || 'sine'](currentFrame - start[0], start[1], end[1] - start[1], frameDiff); }; const Easings = { linear: (t, b, c, d) => b + (c * (t / d)), sine: (t, b, c, d) => -c/2 * (Math.cos(Math.PI*t/d) - 1) + b, cubic: (t, b, c, d) => (t/=d/2) < 1 ? c/2*t*t*t + b : c/2*((t-=2)*t*t + 2) + b, quad: (t, b, c, d) => (t/=d/2) < 1 ? c/2*t*t + b : -c/2 * ((--t)*(t-2) - 1) + b, quart: (t, b, c, d) => (t/=d/2) < 1 ? c/2*t*t*t*t + b : -c/2 * ((t-=2)*t*t*t - 2) + b, quint: (t, b, c, d) => (t/=d/2) < 1 ? c/2*t*t*t*t*t + b : c/2*((t-=2)*t*t*t*t + 2) + b, expo: (t, b, c, d) => { if (t==0) return b; if (t==d) return b+c; if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b; return c/2 * (-Math.pow(2, -10 * --t) + 2) + b; }, back: (t, b, c, d) => (t/=d/2) < 1 ? c/2*(t*t*((3.6)*t - 2.6)) + b : c/2*((t-=2)*t*(3.6*t + 2.6) + 2) + b, bounce: (t, b, c, d) => t < d/2 ? Easings.bounceIn(t*2, 0, c, d) * .5 + b : Easings.bounceOut(t*2-d, 0, c, d) * .5 + c*.5 + b, elastic: (t, b, c, d) => { var s=1.70158;var p=0;var a=c; if (t==0) return b; if ((t/=d/2)==2) return b+c; if (!p) p=d*(.3*1.5); if (a < Math.abs(c)) { a=c; var s=p/4; } else var s = p/(2*Math.PI) * Math.asin (c/a); if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b; }, circular: (t, b, c, d) => (t/=d/2) < 1 ? -c/2 * (Math.sqrt(1 - t*t) - 1) + b : c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b, sineIn: (t, b, c, d) => -c * Math.cos(t/d * (Math.PI/2)) + c + b, cubicIn: (t, b, c, d) => c*(t/=d)*t*t + b, quadIn: (t, b, c, d) => c*(t/=d)*t + b, quartIn: (t, b, c, d) => c*(t/=d)*t*t*t + b, expoIn: (t, b, c, d) => (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b, circularIn: (t, b, c, d) => -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b, backIn: (t, b, c, d) => c*(t/=d)*t*(2.7*t - 1.7) + b, bounceIn: (t, b, c, d) => c - Easings.bounceOut(d-t, 0, c, d) + b, elasticIn: (t, b, c, d) => { var s=1.70158;var p=0;var a=c; if (t==0) return b; if ((t/=d)==1) return b+c; if (!p) p=d*.3; if (a < Math.abs(c)) { a=c; var s=p/4; } else var s = p/(2*Math.PI) * Math.asin (c/a); return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b; }, sineOut: (t, b, c, d) => c * Math.sin(t/d * (Math.PI/2)) + b, cubicOut: (t, b, c, d) => c*((t=t/d-1)*t*t + 1) + b, quadOut: (t, b, c, d) => -c *(t/=d)*(t-2) + b, quartOut: (t, b, c, d) => -c * ((t=t/d-1)*t*t*t - 1) + b, expoOut: (t, b, c, d) => (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b, circularOut:(t, b, c, d) => c * Math.sqrt(1 - (t=t/d-1)*t) + b, backOut: (t, b, c, d) => c*((t=t/d-1)*t*(2.7*t + 1.7) + 1) + b, bounceOut: (t, b, c, d) => { if ((t/=d) < (1/2.75)) { return c*(7.5625*t*t) + b; } else if (t < (2/2.75)) { return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b; } else if (t < (2.5/2.75)) { return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b; } else { return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b; } }, elasticOut:(t, b, c, d) => { var s=1.70158;var p=0;var a=c; if (t==0) return b; if ((t/=d)==1) return b+c; if (!p) p=d*.3; if (a < Math.abs(c)) { a=c; var s=p/4; } else var s = p/(2*Math.PI) * Math.asin (c/a); return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b; } }; } export module Input { type ClickableObject = { obj : GameObject; x0 : number; x1 : number; y0 : number; y1 : number; circ: boolean; }; interface KeyBoard { down : string; up : string; pressed : string[]; }; interface MouseButton { down : boolean; up : boolean; doubleUp : boolean; pressed : boolean; drag : boolean; startDrag : boolean; endDrag : boolean; dragging : boolean; dragPts : {x: number, y: number}[]; }; export interface Mouse { x: number, y: number, left : MouseButton; right : MouseButton; }; const CLICKCODE: string[] = ['left', 'middle', 'right']; let dragCheck = { tolerance : 40, originX : 0, originY : 0, dragPts : [] }, dblClickWait : number = 500, customCursor : (ctx: CanvasRenderingContext2D, delta: number) => void, clickableObjects: ClickableObject[] = []; export let mouse: Mouse = { x: 0, y: 0, left: { down : false, up : false, doubleUp : false, pressed : false, drag : false, startDrag : false, endDrag : false, dragging : false, dragPts : [] }, right: { down : false, up : false, doubleUp : false, pressed : false, drag : false, startDrag : false, endDrag : false, dragging : false, dragPts : [] } }, key: KeyBoard = { up : null, down : null, pressed : [] }; export function init(): void { window.addEventListener('mousemove', onMouseMove.bind(this)); window.addEventListener('mousedown', onMouseDown.bind(this)); window.addEventListener('mouseup' , onMouseUp.bind(this)); window.onkeydown = onKeyDown.bind(this); window.onkeyup = onKeyUp.bind(this); toggleContextMenu(false); }; export function step(): void { emitClickableObjectEvents(); resetMouseButton(mouse.left); resetMouseButton(mouse.right); key.down = null; key.up = null; }; export function setDragTolerance(tolerance: number): void { dragCheck.tolerance = tolerance; }; export function setDoubleClickWait(v: number): void { dblClickWait = v; }; export function toggleContextMenu(show: boolean = true): void { if (show) { window.oncontextmenu = function (e) { }; } else { window.oncontextmenu = function (e) { e.preventDefault(); }; } }; export function isPressed(...keys: string[]): boolean | object { return keys.some(k => key.pressed.indexOf(k) !== -1); }; export function mouseInArea(a?: World.Area): {x: number, y: number} { let view = a ? a.view : World.area.view; return { x: (mouse.x / view.z) + view.x, y: (mouse.y / view.z) + view.y }; } export function setCursor(cursor: ((ctx: CanvasRenderingContext2D, delta: number)=>void) | string): void { if (typeof cursor === 'string') { (Engine.getCanvasEl() as HTMLElement).style.cursor = cursor; } else { (Engine.getCanvasEl() as HTMLElement).style.cursor = 'none'; customCursor = cursor; } }; export function drawCursor(ctx: CanvasRenderingContext2D, delta: number): void { if (customCursor) { ctx.save(); ctx.translate(mouse.x, mouse.y); customCursor(ctx, delta); ctx.restore(); } }; export function setMouseListener( g: GameObject, width: number, height: number, circular: boolean = false, centered: boolean = false ): void { let x0, y0, x1, y1 = 0; if (circular) { x1 = y1 = width / 2; if (!centered) { x0 = y0 = width / 2; } } else if (centered) { x0 = -width / 2; x1 = width / 2; y0 = -height / 2; y1 = height /2; } else { x1 = width; y1 = height; } clickableObjects.push({ obj: g, x0: x0, x1: x1, y0: y0, y1: y1, circ: circular }); }; export function setMouseListenerFromSprite( g: GameObject, sprite: Graphics.SpriteSheet, centered: boolean = false ): void { setMouseListener(g, sprite.width, sprite.height, false, centered); }; function onMouseDown(e: MouseEvent): void { dragCheck.originX = e.clientX; dragCheck.originY = e.clientY; mouse[CLICKCODE[e.button]].pressed = true; mouse[CLICKCODE[e.button]].down = true; }; function onMouseUp(e: MouseEvent): void { let b = mouse[CLICKCODE[e.button]]; b.pressed = false; b.up = true; if (b.dragging) { b.endDrag = true; b.dragging = false; } if (b.dblCheck) { b.doubleUp = true; b.dblCheck = false; } else { b.dblCheck = true; setTimeout(() => b.dblCheck = false, dblClickWait); } }; function onMouseMove(e: MouseEvent): void { mouse.x = e.clientX; mouse.y = e.clientY; checkDrag(mouse.left); checkDrag(mouse.right); }; function checkDrag(b: MouseButton): void { if (b.pressed) { if (!b.dragging) { if ( Math.sqrt( Math.pow(mouse.y - dragCheck.originY, 2) + Math.pow(mouse.x - dragCheck.originX, 2) ) > dragCheck.tolerance ) { b.dragging = true; b.dragPts = []; dragCheck.dragPts.forEach(p => b.dragPts.push({ x: p.x, y: p.y })); dragCheck.dragPts = []; } else { dragCheck.dragPts.push({ x: mouse.x, y: mouse.y }); } } else { b.drag = true; b.dragPts.push({ x: mouse.x, y: mouse.y }); } } }; function resetMouseButton(b: MouseButton): void { b.down = false; b.up = false; b.doubleUp = false; b.drag = false; b.startDrag = false; b.endDrag = false; }; function onKeyDown(e: KeyboardEvent): void { key.down = e.code; if (key.pressed.indexOf(e.code) === -1) { key.pressed.push(e.code); } }; function onKeyUp(e: KeyboardEvent): void { key.up = e.code; key.pressed.splice(key.pressed.indexOf(e.code), 1); }; function emitClickableObjectEvents() { clickableObjects.forEach(o => { if (o.obj.onMouseOver) { let clicked: boolean; if (o.circ) { clicked = Math.sqrt( Math.pow(mouse.y - (o.obj.y + o.y0), 2) + Math.pow(mouse.x - (o.obj.x + o.x0), 2) ) < o.x1; } else { clicked = o.obj.x - o.x0 < mouse.x && o.obj.x + o.x1 > mouse.x && o.obj.y - o.y0 > mouse.y && o.obj.y + o.y1 > mouse.y; } if (clicked) { o.obj.onMouseOver.call(o.obj, mouse); } } }); }; } export module Light { let can0: HTMLCanvasElement, ctx0: CanvasRenderingContext2D, can1: HTMLCanvasElement, ctx1: CanvasRenderingContext2D, can2: HTMLCanvasElement, ctx2: CanvasRenderingContext2D; function lightEngineInit() { can0 = document.createElement('canvas'); ctx0 = can0.getContext('2d'); can1 = document.createElement('canvas'); ctx1 = can1.getContext('2d'); can2 = document.createElement('canvas'); ctx2 = can2.getContext('2d'); can0.width = can1.width = can2.width = Engine.cW; can0.height = can1.height = can2.height = Engine.cH; ctx0.imageSmoothingEnabled = false; ctx1.imageSmoothingEnabled = false; ctx2.imageSmoothingEnabled = false; } function angDiff(a0: number, a1: number): number { let a = a0 - a1; a += (a > Math.PI) ? -2 * Math.PI : (a < -Math.PI) ? 2 * Math.PI : 0; return a; }; function getAng(x: number, y: number): number { return (6.2832 + Math.atan2(y, x)) % 6.2832; }; export class LightArea { public active: boolean = true; public sources: Source[] = []; public blocks: Block[] = []; /* bgLight is a hex value of the background light of the area, defaults to #000000ff (fully opaque black) bgLight can also be a CanvasGradient, which will be used to fill the area background */ constructor( public area: World.Area, bgLight: string | CanvasGradient = '#000' ) { if (!can1) { lightEngineInit(); } ctx0.fillStyle = bgLight; } set bgLight(color: string | CanvasGradient) { ctx0.fillStyle = color; } public addSource(source: Source | Source[]) { [].concat(source).forEach(s => { s.delete(); s.lightArea = this; this.sources.push(s); }); } public addBlock(block: Block | Block[]) { [].concat(block).forEach(s => { s.delete(); s.lightArea = this; this.blocks.push(s); }); } public draw(ctx: CanvasRenderingContext2D) { if (!this.active) { return; } ctx1.clearRect(0, 0, can1.width, can1.height); ctx2.save(); ctx2.scale(this.area.view.z, this.area.view.z); ctx2.translate(-this.area.view.x, -this.area.view.y); this.sources .filter(s => ( s.active && s.x + s.rad > this.area.view.x && s.x - s.rad < this.area.view.x + this.area.view.width && s.y + s.rad > this.area.view.y && s.y - s.rad < this.area.view.y + this.area.view.height )) .forEach(source => { if (!source.castShadows) { ctx1.save(); ctx1.scale(this.area.view.z, this.area.view.z); ctx1.translate(source.x - this.area.view.x, source.y - this.area.view.y); ctx1.rotate(source.ang); ctx1.globalCompositeOperation = 'soft-light'; ctx1.drawImage(source.mask, -source.rad, -source.rad); ctx1.restore(); } else { let nearBlocks: [Block, number][] = [], sourceInBlock = false; this.blocks.forEach(block => { let dis = Math.pow(block.x + block.maskCenter.x - source.x, 2) + Math.pow(block.y + block.maskCenter.y - source.y, 2); if (dis < Math.pow(source.rad + block.clipRad, 2)) { if (block.blockLightInside && dis < Math.pow(block.clipRad, 2)) { sourceInBlock = true; } for (let i = 0; i <= nearBlocks.length; i++) { if (i === nearBlocks.length) { nearBlocks.push([block, dis]); break; } if (dis > nearBlocks[i][1]) { nearBlocks.splice(i, 0, [block, dis]); break; } } } }); if (!sourceInBlock) { ctx2.save(); ctx2.translate(source.x, source.y); ctx2.rotate(source.ang); ctx2.globalCompositeOperation = 'source-over'; ctx2.drawImage(source.mask, -source.rad, -source.rad); ctx2.restore(); nearBlocks.map(b => b[0]).forEach(block => { let corners: {x: number, y: number}[] = []; if (block.mask) { let poly = block.mask.map(m => { return { x: m.x + block.x - source.x, y: m.y + block.y - source.y } }), diff = 3.1416 - getAng(block.x + block.maskCenter.x - source.x, block.y + block.maskCenter.y - source.y), sAng = Math.sin(diff), cAng = Math.cos(diff), max = 3.1416, min = 3.1416, maxP: {x: number, y: number}, minP: {x: number, y: number}; poly.forEach(p => { let a = getAng( (p.x * cAng) - (p.y * sAng), (p.x * sAng) + (p.y * cAng) ); if (a > max) { max = a; maxP = p; } else if (a < min) { min = a; minP = p; } }); corners.push( { x: minP.x + source.x, y: minP.y + source.y }, { x: maxP.x + source.x, y: maxP.y + source.y }, ); } else { let angDiff = getAng(block.x - source.x, block.y - source.y); corners.push( { x: block.x + (Math.cos(angDiff - (Math.PI / 2)) * block.clipRad), y: block.y + (Math.sin(angDiff - (Math.PI / 2)) * block.clipRad) }, { x: block.x + (Math.cos(angDiff + (Math.PI / 2)) * block.clipRad), y: block.y + (Math.sin(angDiff + (Math.PI / 2)) * block.clipRad) } ); } let ang = Math.atan2( corners[1].y - source.y, corners[1].x - source.x ); corners.push({ x : source.x + (source.rad * Math.cos(ang)), y : source.y + (source.rad * Math.sin(ang)) }); ang = Math.atan2( corners[0].y - source.y, corners[0].x - source.x ); corners.push({ x : source.x + source.rad * Math.cos(ang), y : source.y + source.rad * Math.sin(ang) }); ctx2.beginPath(); ctx2.moveTo(corners[0].x, corners[0].y); ctx2.lineTo(corners[1].x, corners[1].y); ctx2.lineTo(corners[2].x, corners[2].y); ctx2.lineTo(corners[3].x, corners[3].y); let ang0 = Math.atan2( corners[2].y - source.y, corners[2].x - source.x ); let ang1 = Math.atan2( corners[3].y - source.y, corners[3].x - source.x ); ctx2.arc( source.x, source.y, source.rad, ang0, ang1, angDiff(ang0, ang1) > 0 ); ctx2.lineTo(corners[0].x, corners[0].y); ctx2.fillStyle = block.translucentColor; ctx2.globalCompositeOperation = 'destination-out'; ctx2.fill(); if (block.translucentColor === '#000') { ctx2.save(); block.spriteMask(ctx2); ctx2.restore(); } ctx2.globalCompositeOperation = 'source-atop'; ctx2.fill(); }); ctx1.globalCompositeOperation = 'lighter'; ctx1.drawImage(can2, 0, 0); ctx2.save(); ctx2.setTransform(1, 0, 0, 1, 0, 0); ctx2.clearRect(0, 0, can2.width, can2.height); ctx2.restore(); } } }); ctx2.restore(); ctx0.globalCompositeOperation = 'source-over'; ctx0.clearRect(0, 0, can0.width, can0.height); ctx0.fillRect(0, 0, can0.width, can0.height); ctx0.globalCompositeOperation = 'destination-out'; ctx0.drawImage(can1, 0, 0); ctx.globalCompositeOperation = 'source-over'; ctx.drawImage(can0, 0, 0); ctx.globalCompositeOperation = 'lighter'; ctx.drawImage(can1, 0, 0); ctx.globalCompositeOperation = 'source-over'; } } export class Source { public active: boolean = true; public ang: number = 0; public mask: HTMLCanvasElement; public lightArea: LightArea; private maskCtx: CanvasRenderingContext2D; private _rad: number; private _color: string; private transColor: string; private _arc: number; private _edgeBlur: number; public customMask: (ctx: CanvasRenderingContext2D, radius: number, color: string)=>void; constructor( public x: number, public y: number, rad: number, color: string = '#fff', public castShadows: boolean = true, arc: number = 6.2832, edgeBlur: number = 0 ) { this._rad = rad; this._arc = arc; this._edgeBlur = edgeBlur; this.mask = document.createElement('canvas'); this.maskCtx = this.mask.getContext('2d'); this.mask.width = this.mask.height = rad * 2; this.color = color; if (!World.area.light) { console.error('Bunas Light Error: Can\'t add Block before calling Area.toggleLight()'); return; } World.area.light.addSource(this); this.lightArea = World.area.light; } get rad(): number { return this._rad; } set rad(newRad: number) { if (newRad < 1) { this._rad = 1; this.active = false; } else if (newRad !== this._rad) { this._rad = newRad; this.active = true; this.mask.width = this.mask.height = newRad * 2; this.setMask(); } } get opacity(): number { return parseInt(this._color.substr(7, 2), 16) / 255; } set opacity(val: number) { let val16 = Math.floor(Math.max(0, Math.min(1, val)) * 255).toString(16); this.color = this._color.substring(0, 7) + (val16.length === 1 ? '0' + val16 : val16); } get color(): string { return this._color; } set color(val: string) { if (val.length === 4) { val = '#' + val[1] + val[1] + val[2] + val[2] + val[3] + val[3]; } else if (val.length === 5) { val = '#' + val[1] + val[1] + val[2] + val[2] + val[3] + val[3] + val[4] + val[4]; } if (val.length === 7) { val += 'ff'; } this._color = val; this.transColor = val.substring(0, 7) + '00'; this.setMask(); } set arc(newArc: number) { if (newArc !== this._arc) { this._arc = newArc; this.setMask(); } } set edgeBlur(newBlur: number) { if (newBlur !== this._edgeBlur) { this._edgeBlur = newBlur; this.setMask(); } } private setMask() { this.maskCtx.save(); this.maskCtx.translate(this._rad, this._rad); if (this.customMask) { this.customMask(this.maskCtx, this._rad, this._color); } else { this.maskCtx.beginPath(); this.maskCtx.moveTo(0, 0); this.maskCtx.arc( 0, 0, this._rad, this._arc / -2, this._arc / 2 ); this.maskCtx.lineTo(0, 0); if (this._arc < 6.282 && this._edgeBlur > 0) { let blurX = Math.asin(this._arc / 2) * this._edgeBlur, blurY = Math.acos(this._arc / 2) * this._edgeBlur; let grdLinTop = this.maskCtx.createLinearGradient(0, 0, blurX, blurY); grdLinTop.addColorStop(0, this.transColor); grdLinTop.addColorStop(1, this._color); let grdLinBtm = this.maskCtx.createLinearGradient(0, 0, blurX, -blurY); grdLinBtm.addColorStop(0, this.transColor); grdLinBtm.addColorStop(1, this._color); this.maskCtx.fillStyle = grdLinTop; this.maskCtx.fill(); this.maskCtx.globalCompositeOperation = 'source-in'; this.maskCtx.fillStyle = grdLinBtm; this.maskCtx.fill(); } let grdRad = this.maskCtx.createRadialGradient(0, 0, 0, 0, 0, this._rad); grdRad.addColorStop(0, this._color); grdRad.addColorStop(1, this.transColor); this.maskCtx.fillStyle = grdRad; this.maskCtx.fill(); } this.maskCtx.restore(); } public delete() { if (this.lightArea) { this.lightArea.sources.splice(this.lightArea.sources.indexOf(this), 1); } this.lightArea = null; } } export class Block { public mask: {x: number, y: number}[]; public maskCenter: {x: number, y: number}; public _ang: number = 0; public clipRad: number; public lightArea: LightArea; public spriteMask: (ctx: CanvasRenderingContext2D)=>void; constructor( public x: number, public y: number, mask: {x: number, y: number}[] | {width: number, height: number} | number, spriteMask?: HTMLImageElement | ((ctx: CanvasRenderingContext2D)=>void), public blockLightInside: boolean = false, public translucentColor = '#000' ) { if (!World.area.light) { console.error('Bunas Error - Light: Tried to add Block before calling Area.toggleLight().'); return; } World.area.light.addBlock(this); this.lightArea = World.area.light; if (typeof mask === 'number') { this.clipRad = mask; } else { if (!Array.isArray(mask)) { let w = mask.width / 2, h = mask.height / 2; mask = [ {x: this.x - w, y: this.y - h}, {x: this.x + w, y: this.y - h}, {x: this.x + w, y: this.y + h}, {x: this.x - w, y: this.y + h} ]; } this.mask = mask; let minX = this.mask.reduce((min, p) => Math.min(min, p.x), this.mask[0].x), maxX = this.mask.reduce((max, p) => Math.max(max, p.x), this.mask[0].x), minY = this.mask.reduce((min, p) => Math.min(min, p.y), this.mask[0].y), maxY = this.mask.reduce((max, p) => Math.max(max, p.y), this.mask[0].y); this.clipRad = Math.sqrt(Math.pow(maxX - minX, 2) + Math.pow(maxY - minY, 2)) / 2; this.maskCenter = { x: minX + ((maxX - minX) / 2), y: minY + ((maxY - minY) / 2) }; } if (typeof spriteMask === 'undefined') { if (typeof this.mask === 'number') { this.spriteMask = ctx => { ctx.beginPath(); ctx.arc(this.x, this.y, this.clipRad, 0, Math.PI * 2); ctx.fill(); } } else { this.spriteMask = ctx => { ctx.translate(this.x, this.y); ctx.rotate(this._ang); ctx.beginPath(); (this.mask as {x: number, y: number}[]).forEach(p => ctx.lineTo(p.x, p.y)); ctx.closePath(); ctx.fill(); } } } else if (typeof spriteMask === 'function') { this.spriteMask = spriteMask; } else { this.spriteMask = ctx => { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this._ang); ctx.drawImage(spriteMask, this.x, this.y); ctx.restore(); } } } get ang(): number { return this._ang; } set ang(newVal: number) { if (newVal !== this._ang) { if (this.mask) { let xDiff = Math.cos(newVal - this._ang), yDiff = Math.sin(newVal - this._ang); this.mask.forEach(p => { p.x -= this.maskCenter.x, p.y -= this.maskCenter.y; let newX = (p.x * xDiff) - (p.y * yDiff), newY = (p.x * yDiff) + (p.y * xDiff); p.x = newX + this.maskCenter.x; p.y = newY + this.maskCenter.y; }); } this._ang = newVal; } } public delete() { if (this.lightArea) { this.lightArea.blocks.splice(this.lightArea.blocks.indexOf(this), 1); } this.lightArea = null; } } } export module Matter { export type Vector = { x: number; y: number; create?: (x: number, y: number)=> Vector; div?: (v: Vector, s: number)=> Vector; mult?: (v: Vector, s: number)=> Vector; clone?: (a: Vector)=> Vector; add?: (a: Vector, b: Vector)=> Vector; angle?: (a: Vector, b: Vector)=> Vector; cross?: (a: Vector, b: Vector)=> Vector; cross3?: (a: Vector, b: Vector, c: Vector)=> Vector; dot?: (a: Vector, b: Vector)=> number; sub?: (a: Vector, b: Vector)=> Vector; perp?: (v: Vector, negate?: boolean)=> Vector; neg?: (a: Vector)=> Vector; rotate?: (a: Vector, ang: number)=> Vector; normalise?: (a: Vector)=> Vector; magnitude?: (a: Vector)=> number; rotateAbout?: (a: Vector, ang: number, p: number)=> Vector; magnitudeSquared?: (a: Vector)=> number; }; type Matter = { Engine: Engine, World: World, Body: Body, Bodies: Bodies, Query: Query, Vector: Vector }; type Engine = { world: World; timing : { timeScale: number; timestamp: number; }; clear: (e: Engine)=> void; create: (opts?: object)=> Engine; merge: (a: Engine, b: Engine)=> Engine; run: (a: Engine)=> void; }; type World = { gravity: { scale: number; x: number; y: number; }, add: (w: World, b: Body | Body[])=> void; remove: (w: World, b: Body)=> void; }; export type Body = { friction: number; frictionAir: number; frictionStatic: number; isStatic: boolean; mass: number; restitution: number; slop: number; readonly id: number; readonly angle: number; readonly angularSpeed: number; readonly angularVelocity: number; readonly area: string; readonly axes: Vector[]; readonly density: number; readonly force: Vector; readonly motion: number; readonly parent: Body; readonly parts: Body[]; readonly position: Vector; readonly speed: number; readonly torque: number; readonly velocity: Vector; readonly vertices: number; create: (opts?: object)=> Body; rotate: (b: Body, ang: number, p?: Vector)=> void; scale: (b: Body, x: number, y: number, p?: Vector)=> void; set: (b: Body, s: string | {p: string, v: any}[], v?: any)=> void; setPosition: (b: Body, v: Vector)=> void; applyForce: (b: Body, p: Vector, f: Vector)=> void; translate: (b: Body, t: Vector)=> void; }; type Bodies = { circle: (x: number, y: number, r: number, opts?: object, max?: number)=> Body; polygon: (x: number, y: number, sides: number, r: number, opts?: object)=> Body; rectangle: (x: number, y: number, w: number, h: number, opts?: object)=> Body; trapezoid: (x: number, y: number, w: number, h: number, slope: number, opts?: object)=> Body; fromVertices: ( x: number, y: number, v?: Vector[], opts?: object, internal?: boolean, removeCollinear?: number, minArea?: number )=> Body; }; type Query = { collides: (b: Body, bodies: Body[])=> Body[]; point: (bodies: Body[], point: Vector)=> Body[]; ray: (bodies: Body[], start: Vector, end: Vector, width?: number)=> Object[]; region: (bodies: Body[], bounds: Object, outside?: Boolean)=> Body[]; }; declare let MatterJs: Matter; let M: Matter = MatterJs, mainEng: Engine; export function init(topDown: boolean = false): void { mainEng = M.Engine.create(); if (topDown) { mainEng.world.gravity.y = 0; } M.Engine.run(mainEng); }; export let Query = { ray: function( area: World.Area, start: Vector, end: Vector, width: number = 1 ): BodyBase[] { return area.objs.filter(b => b instanceof BodyBase && M.Query.ray([b.body], start, end, width) ).map(b => b as BodyBase); } }; class BodyBase extends GameObject { constructor( public body: Body ) { super(body.position.x, body.position.y); M.World.add(mainEng.world, body); } public delete() { M.World.remove(mainEng.world, this.body); super.delete(); } public rotate(ang: number, p?: Vector): void { M.Body.rotate(this.body, ang, p); } public scale(x: number, y: number, p?: Vector): void { M.Body.scale(this.body, x, y, p); } public translate(v: Vector | number, y?: number): void { if (typeof v === 'number') { v = M.Vector.create(v, y); } M.Body.translate(this.body, v); } public applyForce(f: Vector, p?: Vector): void { M.Body.applyForce(this.body, p || this.body.position, f); } public setProp(p: string | {[p: string]: any}, v?: any) { if (typeof p === 'string') { M.Body.set(this.body, p, v); } else { for (let prop in p) { M.Body.set(this.body, prop, p[prop]); } } } public collisions(bodies?: BodyBase[]): BodyBase[] { if (!bodies) { bodies = this.area.objs .filter(b => b instanceof BodyBase && b !== this) .map(b => b as BodyBase); } return bodies.filter(b => M.Query.collides(this.body, [b.body]).length); } get ang(): number { return this.body.angle; }; get x(): number { return this.body.position.x }; set x(v: number) { this.body ? M.Body.setPosition(this.body, {x: v, y: this.body.position.y}) : ''; }; get y(): number { return this.body.position.y }; set y(v: number) { this.body ? M.Body.setPosition(this.body, {x: this.body.position.x, y: v}) : ''; }; }; export class Rect extends BodyBase { constructor( x: number, y: number, private w: number, private h?: number ) { super(M.Bodies.rectangle(x, y, w, h || w, { frictionAir : 0 })); if (typeof this.h === 'undefined') { this.h = this.w; } } public draw(ctx: CanvasRenderingContext2D) { ctx.translate(this.x - (this.w / 2), this.y - (this.h / 2)); ctx.rotate(this.ang); ctx.fillRect(0, 0, this.w, this.h); } }; export class Circ extends BodyBase { constructor( x: number, y: number, public r: number ) { super(M.Bodies.circle(x, y, r, { frictionAir : 0 })); } public draw(ctx: CanvasRenderingContext2D) { ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2); ctx.fill(); } }; } export module Physics { export const GRAV = 41.18, TAU = 6.2832; let globalCtx; export class Vec { public x: number; public y: number; constructor(xm: number = 1, ya: number = 0, polar = false) { if (polar) { this.setMagAng(xm, ya); } else { this.x = xm; this.y = ya; } } public setAng(rad: number): void { let mag = this.getMag(); this.x = Math.cos(rad) * mag; this.y = Math.sin(rad) * mag; } public setMagAng(mag: number, ang: number): void { this.x = Math.cos(ang) * mag; this.y = Math.sin(ang) * mag; } public getAng(): number { return Math.atan2(this.y, this.x); } public static getAng(v: Vec | Matter.Vector): number { return Math.atan2(v.y, v.x); } public getMag(): number { return Math.sqrt((this.x * this.x) + (this.y * this.y)); } public static getMag(v: Vec | Matter.Vector): number { return Math.sqrt((v.x * v.x) + (v.y * v.y)); } public getNorm(): Vec { let ang = this.getAng(); return new Vec(Math.cos(ang), Math.sin(ang)); } public add(v: Vec | Matter.Vector): Vec { return new Vec(this.x + v.x, this.y + v.y); } public sub(v: Vec | Matter.Vector): Vec { return new Vec(this.x - v.x, this.y -v.y); } public scale(s: number): Vec { return new Vec(this.x * s, this.y * s); } public dot(v:Vec | Matter.Vector): number { return (this.x * v.x) + (this.y * v.y) } public dis(v:Vec | Matter.Vector): number { let a = (v.x - this.x) * (v.x - this.x); let b = (v.y - this.y) * (v.y - this.y); return Math.sqrt(a + b); } public angWith(v:Vec | Matter.Vector): number { return Math.atan2(v.y - this.y, v.x - this.x); } public toString(): String { let pos = '<' + Math.round(this.x) + ', ' + Math.round(this.y) + '>'; let mag = Math.round(this.getMag() * 100) / 100; let angR = Math.round(this.getAng() * 100) / 1000; let angD = Math.round(angR * (180 / Math.PI)); return ('Pos: ' + pos + '\nMag: ' + mag + '\nAng: ' + angR + ' rads / ' + angD + '°'); } public clone(): Vec { return new Vec(this.x, this.y); } } export class Context { private objs: Particle[] = []; public grav: Vec; constructor( public fric: number = 0, gravity: boolean | number | Vec = false ) { if (gravity === true) { this.grav = new Vec(0, GRAV); } else if (typeof gravity === 'number') { this.grav = new Vec(0, gravity); } else { this.grav = gravity as Vec; } } public addParticle(p: Particle): Particle { this.objs.push(p); p.phyCtx = this; return p; } } export class Particle extends GameObject { public p: Vec; public v: Vec = new Vec(0, 0); public f: Vec = new Vec(0, 0); public phyCtx: Context; constructor( public x : number, public y : number, public rad : number, public fric : number = 0, public el : number = 0.5, public m : number = rad / 2 ) { super(x, y, 0, rad); this.p = new Vec(x, y); if (!globalCtx) { globalCtx = new Context(); } globalCtx.addParticle(this); } public step(delta) { if (this.phyCtx.grav) { this.applyForce(this.phyCtx.grav); } let friction: Vec = this.v.clone(); friction.setAng((friction.getAng() + Math.PI) % (2 * Math.PI)); friction = friction.scale(this.m * this.phyCtx.fric * this.fric); this.f = this.f.add(friction); this.f.scale(delta); this.v = this.v.add(this.f); if (this.v.getMag() > 0.1) { this.p = this.p.add(this.v); this.x = this.p.x; this.y = this.p.y; } else if (this.v.getMag() !== 0) { this.v = new Vec(0, 0); } this.f = new Vec(0, 0); this.collisionAndBounce(); } public draw(ctx, dT) { ctx.beginPath(); ctx.strokeStyle = 'dodgerblue'; ctx.arc(this.p.x, this.p.y, this.rad - 2, 0, TAU); ctx.stroke(); } public applyForce(F: Vec) { this.f = this.f.add(F); } private collisionAndBounce = function() { for (let i = 0, len = this.phyCtx.objs.length; i < len; i++) { if ((this.phyCtx.objs[i] != this) && ((this.p.dis(this.phyCtx.objs[i].p) - (this.rad + this.phyCtx.objs[i].rad) < 0)) ) { let delta: Vec = this.p.sub(this.phyCtx.objs[i].p); let d: number = delta.getMag(); var mtd = delta.scale(((this.rad + this.phyCtx.objs[i].rad) - d) / d); let im1: number = 1 / this.m; let im2: number = 1 / this.phyCtx.objs[i].m; this.p = this.p.add(mtd.scale(im1 / (im1 + im2))); this.phyCtx.objs[i].p = this.phyCtx.objs[i].p.sub(mtd.scale(im2 / (im1 + im2))); let iv: Vec = this.v.sub(this.phyCtx.objs[i].v); mtd = mtd.getNorm(); let vn: number = iv.dot(mtd); if (vn <= 0) { var imp = ((-1 * vn) * (1 + this.el)) / (im1 + im2); var impulse = mtd.scale(imp); this.v = this.v.add(impulse.scale(im1)); this.phyCtx.objs[i].v = this.phyCtx.objs[i].v.sub(impulse.scale(im2)); } } } } } } export module World { export type background = { name: string, img: HTMLImageElement | string, parralax: {x: number, y: number}, repeat: {x: boolean, y: boolean}, offset: {x: number, y: number}, z: number }; export let area: Area; let areas: { [name: string]: Area } = {}, currentAreas: Area[] = []; export function step(dT: number) { currentAreas.forEach(a => a.step(dT)); }; export function draw(ctx: CanvasRenderingContext2D, dT: number) { currentAreas.forEach(a => a.draw(ctx, dT)); }; /* Opens a new area, if replace is false the previous Area is not closed first */ export function goTo(areaName: string, replace: boolean = true) { if (replace) { currentAreas.forEach(a => a.close()); } areas[areaName].open(); }; export class Area { public objs: GameObject[] = []; public view: View; public light: Light.LightArea; private active: boolean = false; private _zIndex: number; private layout: { grid: string; objects: {[instance: string]: any[]}; width: number; height: number; x: number, y: number }; private backgrounds: background[] = []; private foregrounds: background[] = []; constructor( private name : string, private persist : boolean = false, zIndex : number = 0, public onInit : ()=>void = ()=>{}, public onOpen : ()=>void = ()=>{}, public onClose : ()=>void = ()=>{}, ) { areas[name] = this; this.view = new View(); this._zIndex = zIndex; }; get zIndex(): number { return this._zIndex; } set zIndex(newVal: number) { this._zIndex = newVal; currentAreas.sort((a, b) => a.zIndex - b.zIndex); } public addBackground( asset: string, isForeGround: boolean = false, zIndex: number = 0, parralax: number | {x: number, y: number} = 1, offset: number | {x: number, y: number} = 0, repeat: boolean | {x: boolean, y: boolean} = true, customName?: string ): background { let bg = { name: customName || asset, img: Engine.getBackground(asset, true) || asset, parralax: typeof parralax === 'number' ? {x: parralax, y: parralax} : parralax, offset: typeof offset === 'number' ? {x: offset, y: offset} : offset, repeat: typeof repeat === 'boolean' ? {x: repeat, y: repeat} : repeat, z: zIndex }; if (isForeGround) { this.foregrounds.push(bg); this.foregrounds.sort((a, b) => a.z - b.z); } else { this.backgrounds.push(bg); this.backgrounds.sort((a, b) => a.z - b.z); } return bg; } public removeBackground(bg: string | background) { if (typeof bg !== 'string') { bg = bg.name; } this.backgrounds.splice(this.backgrounds.findIndex(x => bg === x.name), 1); this.foregrounds.splice(this.foregrounds.findIndex(x => bg === x.name), 1); } public step(dT: number) { this.objs.forEach(o => o.startStep && o.startStep(dT)); this.objs.forEach(o => o.step(dT)); this.objs.forEach(o => o.endStep && o.endStep(dT)); } public draw(ctx: CanvasRenderingContext2D, dT: number) { ctx.save(); this.view.update(); ctx.scale(this.view.z, this.view.z); ctx.translate(-this.view.x, -this.view.y); this.drawBackgrounds(ctx, false); let visibleObjs = this.objs.filter(o => { if ( o.x + o.clipBox.x + o.clipBox.width > this.view.x && o.x + o.clipBox.x < this.view.x + this.view.width && o.y + o.clipBox.y + o.clipBox.height > this.view.y && o.y + o.clipBox.y < this.view.y + this.view.height ) { o.inView = true; } else { o.inView = false; } return o.inView; }); visibleObjs.forEach(o => o.startDraw && o.startDraw(ctx, dT)); visibleObjs.forEach(o => o.draw(ctx, dT)); visibleObjs.forEach(o => o.endDraw && o.endDraw(ctx, dT)); ctx.restore(); if (this.light) { this.light.draw(ctx); } if (this.foregrounds.length) { ctx.save(); ctx.scale(this.view.z, this.view.z); ctx.translate(-this.view.x, -this.view.y); this.drawBackgrounds(ctx, true); ctx.restore(); } } private drawBackgrounds(ctx: CanvasRenderingContext2D, isForeground: boolean) { this[isForeground ? 'foregrounds' : 'backgrounds'].forEach(bg => { if (typeof bg.img === 'string') { ctx.save(); ctx.fillStyle = bg.img; ctx.fillRect(this.view.x, this.view.y, Engine.cW / this.view.z, Engine.cH / this.view.z); ctx.restore(); } else { let x = (this.view.x * bg.parralax.x) - bg.offset.x; if (bg.repeat.x) { x %= bg.img.width; } x = this.view.x - x; let xEnd = bg.repeat.x ? this.view.x + Engine.cW : x + 1; for (; x < xEnd; x += bg.img.width) { let y = (this.view.y * bg.parralax.y) - bg.offset.y; if (bg.repeat.y) { y %= bg.img.width; } y = this.view.y - y; let yEnd = bg.repeat.y ? this.view.y + Engine.cH : y + 1; for (; y < yEnd; y += bg.img.height) { ctx.drawImage(bg.img, x, y); } } } }); } /* Adds game objects based on an area layout grid string grid - a multiline string where the number of lines is the grid height and the number of characters per line is the grid width each non-space character will add the object its character represents, at a position in the Area relative to its position in the grid string objs - a list of characters, and the GameObjects they represent int he grid string width - the width in px that one character in the grid string represents height - the height in px that one character in the grid string represents, defaults to the width value if not provided x, y - the x position in the Area to start drawing the grid objects */ public setLayout( grid: string, objs: {[instance: string]: any[]}, cellWidth: number, cellHeight?: number, x: number = 0, y: number = 0 ): void { this.layout = { grid: grid, objects: objs, width: cellWidth, height: cellHeight || cellWidth, x: x, y: y }; }; private createLayout() { let grid = this.layout.grid.split('\n'); let startCol = -1, startRow = -1; for (let i = 0; i < grid.length; i++) { let m = grid[i].match(/[a-z0-9]/i); if (m) { if (startCol === -1) { startCol = i; } if (m.index < startRow) { startRow = m.index; } } } grid.forEach((l, row) => { l.replace( /[a-z0-9]/gi, (o, col) => { try { let obj = this.layout.objects[o]; let inst = new obj[0](...obj.slice(1)); inst.x = this.layout.x + ((col - startCol) * this.layout.width); inst.y = this.layout.y + ((row - startRow) * this.layout.height); this.add(inst); } catch { console.error(`Bunas Error: Cannot create object for character "${o}" in level layout`); } return o; } ); }); }; public open(): void { if (!this.active) { if (this.layout) { this.createLayout(); } this.onInit(); this.view.reset(); this.active = true; } currentAreas.push(this); currentAreas.sort((a, b) => a.zIndex - b.zIndex); this.onOpen(); }; public close() { currentAreas.splice(1, currentAreas.indexOf(this)); this.onClose(); if (!this.persist) { this.objs = []; } }; public delete(): void { this.objs = []; if (this.light) { this.light.sources.forEach(s => s.delete()); this.light.blocks.forEach(s => s.delete()); } delete areas[this.name]; } /* Moves a Game Object, or an array of Game Objects, from thier current Area, to this Area */ public add(objs: GameObject | GameObject[]): void { [].concat(objs).forEach(o => { if (o.area) { o.area.remove(o); } for(let i = 0; true; i++) { if (i === this.objs.length || o.z > this.objs[i].z) { this.objs.splice(i, 0, o); break; } } o.area = this; }); }; public remove(o: GameObject): void { this.objs.splice(this.objs.indexOf(o), 1); o.area = null; }; public zSort(o: GameObject) { this.objs.splice(this.objs.indexOf(o), 1); for(let i = 0; true; i++) { if (i === this.objs.length || o.z > this.objs[i].z) { this.objs.splice(i, 0, o); break; } } } public togglePersistance(persist?: boolean) { this.persist = persist === undefined ? !this.persist : persist; if (!this.persist && currentAreas.indexOf(this) === -1) { this.objs = []; } }; public toggleLight(on?: boolean): void { if (!this.light) { this.light = new Light.LightArea(this); } else { this.light.active = typeof on === 'undefined' ? !this.light.active : on; } }; }; export class View { public width: number; public height: number; public tracking: GameObject; private trackOn: boolean = false; private trackPad: number[]; private trackLag: number; private trackBound: number[]; private initX: number; private initY: number; private initZ: number; /* x, y - top left position of View in Area z - View zoom level ang - angle of View in Area width, height - width and height to draw the view on the canvas, default to cover the canvas canX, canY - top left position to draw View on the canvas canZ - scale size to draw the view on the canvas */ constructor( public x: number = 0, public y: number = 0, private _z: number = 1 ) { this.initX = x; this.initY = y; this.initZ = _z; this.width = Engine.cW / _z; this.height = Engine.cH / _z; }; get z(): number { return this._z } set z(val: number) { this._z = val; this.width = Engine.cW / val; this.height = Engine.cH / val; } public track( object : GameObject, padding : number | number[] = 0, trackSpeed : number = 0, bound? : number[] ) { this.tracking = object; this.trackLag = trackSpeed; this.trackOn = true; if (bound) { bound[2] += bound[0]; bound[3] += bound[1]; bound[2] -= this.width; bound[3] -= this.height; this.trackBound = bound; } if (typeof padding === 'number') { this.trackPad = [padding, padding, padding, padding]; } else if (padding.length === 2) { this.trackPad = [...padding, ...padding] } else { this.trackPad = padding; } } public toggleTracking(turnOn?: boolean) { if (typeof turnOn === undefined) { this.trackOn = !this.trackOn; } else { this.trackOn = turnOn; } } public update() { if (this.tracking) { if (this.tracking.y < this.y + this.trackPad[0]) { this.y -= (this.y - this.tracking.y + this.trackPad[0]) * this.trackLag; } if (this.tracking.y > this.y + this.height - this.trackPad[2]) { this.y += (this.tracking.y - (this.y + this.height - this.trackPad[2])) * this.trackLag; } if (this.tracking.x < this.x + this.trackPad[3]) { this.x -= (this.x - this.tracking.x + this.trackPad[3]) * this.trackLag;; } if (this.tracking.x > this.x + this.width - this.trackPad[1]) { this.x += (this.tracking.x - (this.x + this.width - this.trackPad[1])) * this.trackLag;; } if (this.trackBound) { if (this.y < this.trackBound[1]) { this.y = this.trackBound[1]; } else if (this.y > this.trackBound[3]) { this.y = this.trackBound[3]; } if (this.x < this.trackBound[0]) { this.x = this.trackBound[0]; } else if (this.x > this.trackBound[2]) { this.x = this.trackBound[2]; } } this.x = Math.floor(this.x); this.y = Math.floor(this.y); } } public reset() { this.x = this.initX; this.y = this.initY; this.z = this.initZ; } }; }